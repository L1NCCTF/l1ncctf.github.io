[{"categories":null,"contents":"L1NC CTF Team members page\nCaptain: Tuxpad\nMembers:\ni3tani Skipper \u0026hellip; ","permalink":"https://l1ncctf.github.io/about/","tags":null,"title":"About"},{"categories":["Writeups","Web"],"contents":" Challenge Descriptions Revoked: Your budget request for the new company personnel index has been declined. Instead, the intern has received a very small bonus in exchange for a homemade solution. Show them their stinginess could cost them.\nRevoked Revenge: The chall maker forgot to remove a debug account... Here is the revenge challenge without this backdoor!\nAlthough source code for a Flask app was provided, I prefer starting with black‑box testing to understand how the application behaves externally before reviewing internals. After solving the challenge through SQL injection, I went back to the source to analyze exactly why the exploit worked.\nRevoked - Black Box Solution When we enter the challenge we get a login screen with the option of registering a new user. Trying a simple password ' OR 1=1;-- SQLi only returns \u0026ldquo;Invalid credentials\u0026rdquo;, so we\u0026rsquo;ll register a new user.\nLogging in with our new user brings us into an employee directory with a search bar, and in the top right corner is a drop-down for the logged in user. Clicking our username reveals the option \u0026ldquo;Admin panel\u0026rdquo;, but clicking that returns \u0026quot; You don\u0026rsquo;t have the permission to access this area\u0026quot;. Let\u0026rsquo;s try to see if the search bar is vulnerable to SQLi by just entering a single quote. It turns out that it indeed is vulnerable, and we get an internal server error.\nSo we\u0026rsquo;ll start off by trying to get a UNION select query that will display properly and not result in an error. We can discover how many columns the query returns by incrementally adding null values to the UNION SELECT until the query executes without errors.\nLooking at the employee cards we can see that they display a photo, name, position, and a link, so we\u0026rsquo;ll try ' UNION SELECT null, null, null, null;--, which returns an empty employee. If we change the query to 'UNION SELECT 1,2,3,4;-- we can see which is which;\nThe first value affects both the photo and the link, so it appears to be an id. The second value is the employee name. The third value is not shown. The fourth value is the position. Now we know that any values we want displayed should be in the second and fourth positions.\nKnowing which type of database is used will help you knowing how to enumerate it, so that\u0026rsquo;s a good place to start. I\u0026rsquo;m guessing that it\u0026rsquo;s SQLite, so we can query the version to see: ' UNION SELECT 1,sqlite_version(),3,4;--', which shows that it is indeed SQLite.\nNow that we know the type of database, we can enumerate the database tables: ' UNION SELECT 1,2,3, tbl_name FROM sqlite_master WHERE type='table';-- Great! Now we know that there are four tables, and the ones that look interesting for us are users and revoked_tokens. In order to dump the information we want we\u0026rsquo;ll need to know the column names, which we can get by using the following query: ' UNION SELECT 1,2,3, GROUP_CONCAT(name) AS column_names FROM pragma_table_info('users');-- Now we can see that each entry has an id, a username, a \u0026ldquo;is_admin\u0026rdquo; variable, and a password hash. This implies two ways to get the privileges we want; either we insert a value in is_admin to indicate that our user has admin privileges, or we dump and crack the admin hash.\nEither way, we need to know the kind of value used. ' UNION SELECT 1,username,3,is_admin FROM users;-- Now we can see that the app uses integers as booleans.\nWe could try to insert into the database, but SQLite3 (via Python) disallows multiple SQL statements per execute() call, so stacked queries are not possible, and because the base statement is a SELECT, the UNION injection is constrained to SELECT-only syntax. Therefore no INSERT/UPDATE/DELETE payload can be executed.\nInstead we will dump password hashes, and we now know that we can filter for is_admin=1 to only get hashes for admin accounts. ' UNION SELECT 1,password_hash,1,username FROM users WHERE is_admin=1-- It seems that we have two admins, and we get their bcrypt hashes to attempt to crack.\nUsing hashcat mode 3200 with rockyou gives us admin1:pass. (In a CTF where you\u0026rsquo;re supposed to be able to crack the hash, rockyou is the standard wordlist)\nWe can now log in and access the admin panel for the flag. Revoked - White Box Solution We\u0026rsquo;ve already solved the challenge, but let\u0026rsquo;s have a look at why it works, and how we could\u0026rsquo;ve figured it out by reviewing code.\nFrom what we already know after black box testing, we will focus on:\nLogin appears to not be vulnerable to SQLi Employee search is vulnerable to SQLi Login not vulnerable to SQLi\nWe start off by having a look at the code for the login.\n1 2 3 4 5 6 7 user = conn.execute( \u0026#34;SELECT * FROM users WHERE username = ?\u0026#34;, (username,) ).fetchone() conn.close() if user and bcrypt.checkpw( password.encode(\u0026#34;utf-8\u0026#34;), user[\u0026#34;password_hash\u0026#34;].encode(\u0026#34;utf-8\u0026#34;) Here we can see a textbook example of SQLi-safe code that has a prepared statement with parameterized queries.\nThe SQL statement is using a placeholder, ?, and the username is inserted into a tuple and passed, along with the SQL statement to the database engine. SQLite parses the statement and treats the placeholder as a bound parameter slot, and then the actual username is bound to that slot as raw data. Even if you try a SQLi like admin' OR 1=1;--, SQLite will see it as a literal string to match exactly against the username column and not treat it as SQL syntax. SQLite automatically doubles single quotes in string literals, safely escaping SQLi attempts.\nIn addition to this, the password is not part of the query at all; if the user is found in the db, it is fetched and stored in the variable user, and the password entered is hashed and compared to the hash in the user variable.\nEmplyee search SQLi vulnerability\nThe employee search, however, is a classic example of code that is vulnerable.\n1 2 3 cursor.execute( f\u0026#34;SELECT id, name, email, position FROM employees WHERE name LIKE \u0026#39;%{query}%\u0026#39;\u0026#34; ) Here we can see that the f-string directly interpolates the user input, which sent as a query to the database, meaning that the user input will be interpreted as SQL syntax, making it vulnerable to injection attacks.\nFurthermore, as we can see the names of the database tables and columns both in the initialization, and in the queries, constructing a query to fetch the information we need becomes trivial.\nRemediation The search function should be rewritten in the same manner as the login, with a prepared statement and parameterized query.\nRevoked Revenge - White Box Solution This challenge is using exactly the same code as the previous. The only difference is that the admin with a crackable password isn\u0026rsquo;t there. Thus we need to find another way in - and here we will focus on the revoked tokens.\nWhen attacking tokens we could try to either:\nFind the secret used to sign them in order to forge our own token Steal a token for impersonating a user. In the code can see that secret key used to sign tokens is made from 32 random hex characters. So we can forget about cracking it to forge our own token.\n1 2 3 app.config[\u0026#34;SECRET_KEY\u0026#34;] = \u0026#34;\u0026#34;.join( [secrets.choice(\u0026#34;abcdef0123456789\u0026#34;) for _ in range(32)] ) But, the database is flushed at init. This means that any revoked tokens in the database have been made using the current secret.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def init_db(): conn = sqlite3.connect(\u0026#34;database.db\u0026#34;) cursor = conn.cursor() cursor.execute(\u0026#34;\u0026#34;\u0026#34;DROP TABLE IF EXISTS employees;\u0026#34;\u0026#34;\u0026#34;) cursor.execute(\u0026#34;\u0026#34;\u0026#34;DROP TABLE IF EXISTS revoked_tokens;\u0026#34;\u0026#34;\u0026#34;) cursor.execute(\u0026#34;\u0026#34;\u0026#34;DROP TABLE IF EXISTS users;\u0026#34;\u0026#34;\u0026#34;) cursor.execute(\u0026#34;\u0026#34;\u0026#34;CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, is_admin BOOL NOT NULL, password_hash TEXT NOT NULL)\u0026#34;\u0026#34;\u0026#34;) cursor.execute(\u0026#34;\u0026#34;\u0026#34;CREATE TABLE IF NOT EXISTS revoked_tokens ( id INTEGER PRIMARY KEY AUTOINCREMENT, token TEXT NOT NULL)\u0026#34;\u0026#34;\u0026#34;) cursor.execute(\u0026#34;\u0026#34;\u0026#34;CREATE TABLE IF NOT EXISTS employees ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, email TEXT UNIQUE NOT NULL, position TEXT NOT NULL, phone TEXT NOT NULL, location TEXT NOT NULL)\u0026#34;\u0026#34;\u0026#34;) conn.commit() conn.close() As we saw previously, the employee search is vulnerable to SQLi, letting us dump revoked tokens from the database. ' UNION SELECT 1,2,3,token FROM revoked_tokens;--\nDecoding the first token shows us that this is the admins token, that\u0026rsquo;s the one we\u0026rsquo;ll use.\n1 2 3 4 5 { \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;is_admin\u0026#34;: 1, \u0026#34;issued\u0026#34;: 1764771147.1933315 } The vulnerability we will exploit can be found in this part of the code:\n1 2 3 revoked = conn.execute( \u0026#34;SELECT id FROM revoked_tokens WHERE token = ?\u0026#34;, (token,) ).fetchone() This bit of code compares the exact string of the tokens in the revoked_tokens table with the token submitted by the user.\nSo why is this a problem? The answer to this is that JWT are encoded in Base64url, which omits the = padding found in regular Base64. And the problem here is that the PyJWT Base64url decoder is permissive: it accepts both padded and unpadded variants of the same JWT payload/signature.\nSo when the tokens are generated, they lack padding, and this is how they are stored in the database when they are revoked. If we add padding in the form of =, or even ==, to the end of a token, the PyJWT decoder will still be able to successfully decode it as the same token, but in the check against the revoked tokens it will no longer be a match.\nThus, we now have a valid token that bypasses the revocation check and can impersonate the admin user. Remediation This vulnerability can be fixed by simply stripping padding from the token submitted by the user before comparing to the revoked tokens. Padding variations do not change the decoded JWT payload or signature, but they do change the raw string representation used in the SQL lookup.\n1 2 3 4 5 normalized_token = token.rstrip(\u0026#39;=\u0026#39;) revoked = conn.execute( \u0026#34;SELECT id FROM revoked_tokens WHERE token = ?\u0026#34;, (normalized_token,) ).fetchone() As the code is now, this remediates the problem; the tokens generated by PyJWT don\u0026rsquo;t have padding and will be inserted as such. But, even though it is redundant, it\u0026rsquo;s considered best practice to also strip the tokens inserted at logout, because we don\u0026rsquo;t know how the code will be modified in the future, and adding this helps keeping the app secure.\n","permalink":"https://l1ncctf.github.io/post/heroctf-web-revoked/","tags":["HeroCTF","JWT","Flask","SQLi"],"title":"HeroCTF 2025 - Revoked \u0026 Revoked Revenge"},{"categories":["Writeups","Forensic"],"contents":" Challenge Description What is this?! How did someone manage to capture my network traffic? Must've been that damnable ghost in my walls...\nFind all 3 flags and combine them as such flag1---flag2---flag3 in order to scare away the ghost in your walls for good! Note: You are sharing this challenge with the other competitors. Be sneaky, lest you want other teams to know your solution!\nSolution Along with the challenge description you get a pcap with ~10k frames, containing a bunch of encrypted QUIC traffic, as well as TLS encrypted TCP, and some unencrypted HTTP over TCP to sites dedicated to cars.\nPCAP Analysis First, let\u0026rsquo;s just do a string search for \u0026lsquo;Flag\u0026rsquo; to see if there\u0026rsquo;s an easy win. Indeed, the first part of the flag is in a parameter to a HTTP GET request. Next, in order to get an overview of the type of traffic in the pcap,we\u0026rsquo;ll select Statistics -\u0026gt; Protocol Hierarchy from the toolbar menu. This gives us an overview of what we have to work with, like how 74.9% of the traffic is TLS. One thing that sticks out is the seven packets of \u0026lsquo;HTML Form URL Encoded\u0026rsquo;; that might be worth looking at. So, we\u0026rsquo;ll right click on it and apply it as a filter. Immediately, two packets stand out, as they are directed to a different IP address than the rest of the traffic in the pcap. Wait a sec, this is a reverse shell! The author of the challenge isn\u0026rsquo;t going to attack some random site, so this is a clear indicator that we should have a closer look. We follow the stream, which provides more useful information. In addition to the reverse shell attempt, we can see that the server responded \u0026lsquo;b64 command sent\u0026rsquo;, and a second POST request with a hint that it din\u0026rsquo;t work. Getting a foothold When we have a look in the browser we get to a login screen that we\u0026rsquo;ll need to bypass. We can try something like SQLi, but that doesn\u0026rsquo;t work. However, in the pcap we could also see that the POST request also had a session cookie set, and when applying it we bypass the login. Now, the server response said base64 encoded, but the shell was sent in clear text, and then we saw that it didn\u0026rsquo;t work. So, we\u0026rsquo;ll just craft our own reverse shell command, base64 encode it and give it a shot, and we get a shell!\nGetting user account In the webroot directory we can se the document routes.py, which contains the backend for the login, made in Flask. Here we can see the hard coded credentials for the login. A password is always good to collect, as it might be reused somewhere (though that\u0026rsquo;s not the case in this challenge). Now we can start doing some local host enumeration; check OS version, environment variables, user accounts, groups, etc.\nInside /etc/group we find something interesting; it looks like a password for the only user account. Indeed it is, and we can collect the second part of the flag from ~/user.txt Root privesc Since we have the users password, and we\u0026rsquo;re not worried about being detected on the system, let\u0026rsquo;s check if the user has sudo privileges. It turns out that we may run sudo /snap/bin/ls -la /root So let\u0026rsquo;s do just that! We can see the file /root/root.txt, which obviously is where we\u0026rsquo;ll find the final part of the flag. When you find that you have access to a particular command as sudo, you should always consider how that can be abused, particularly if that\u0026rsquo;s the only command you can run as a super user. Perhaps you can pipe something to the command, get the program to run in interactive mode or you can escape it to a shell.\nIn this case, we can see that although the program (/snap/bin/ls) is owned by root, and we only have permission to execute and read, the directory /snap/bin has write permission for all set. This means that although we can\u0026rsquo;t manipulate the contents of the file, we can do things like rename, move, or delete it, and so we can replace it with a shell script which we then can run in sudo! We\u0026rsquo;ll just rename ls, creeate a shell script to cat the flag (we could get a shell, but there\u0026rsquo;s no need), chmod it to be executable, and then run it to get the final part of the flag. ","permalink":"https://l1ncctf.github.io/post/o24-forensic-ghost_in_the_wall/","tags":["WireShark","pcap","Linux","privesc"],"title":"O24 CTF 2024 - Ghost In The Wall"},{"categories":["Writeups","Crypto"],"contents":"Shuffled chunks of bits\nDescription \u0026ldquo;You should do this by hand.\u0026rdquo;\nSolution Ok, so we have a RSA crypto, let\u0026rsquo;s look at the source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from Crypto.Util.number import * import random flag = open(\u0026#39;flag.txt\u0026#39;,\u0026#39;rb\u0026#39;).read() pt = bytes_to_long(flag) bits = 768 p,q = getPrime(bits),getPrime(bits) n = p*q e = 0x10001 print(pow(pt,e,n)) bit_p = bin(p)[2:] bit_q = bin(q)[2:] parts = [bit_p[0:bits//3],bit_p[bits//3:2*bits//3],bit_p[2*bits//3:bits],bit_q[0:bits//3],bit_q[bits//3:2*bits//3],bit_q[2*bits//3:bits]] random.shuffle(parts) print(parts) q \u0026amp; p are 768 bits long, converted into binary, each split into three pieces and put into a list, which is then shuffled. Great, we need to reassemble the primes to be able to solve the crypto.\nI solved it by making a list of all permutations, then trying to solve the crypto with each permutation and checking if the result contains \u0026ldquo;flag\u0026rdquo;. Somehow it didn\u0026rsquo;t work when straight up making the permutations, so I did it by using permutations of the list index, which solved it for me. Now, checking if the permutation actually is a prime would probably have been a good idea instead of looping through all possible permutation, but since there were only six chunks in total it didn\u0026rsquo;t take a long time anyway.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from Crypto.Util.number import * import random from itertools import permutations e = 0x10001 parts = [\u0026#39;0100101100001100010110110001000001001110010110110011101111100001101100000101000011111000101110011010010100101100011111000000101010011101100101010000101101110100100010101011100110001010001000000001000110000111011110011001101111110000100010000110000001110011\u0026#39;, \u0026#39;1100001100001100111110011110110101001100100000000100000100011110110010010101000011111111000100001000111001100110010010010011110110110010010110110100010110100011011100101001100001010111000100000110101010101011011110110110101010110100011110010000101010000111\u0026#39;, \u0026#39;1000100010110110010100111010100100111000100111100101100001011111100011000111110011101011011011100000101011000111010110010010011110100100110000001101110111001000000111100111011011000101010001111101000111100111110010011101011111100100111111011011110110101111\u0026#39;, \u0026#39;1111001101111101111111111111001010001111100010100000010110011011100000000110010110000011011110101110001000001111110101101101111000000111101111111000011101011010000110111100000110000001001101101010100000010011000100010111100001011000101101111000101101110100\u0026#39;, \u0026#39;1100100000100001010111110010000011000010100110101111100100011010111111110100011011111100001011101001010000100111100011100111000101110001001011110000000000000000000110111100000111100000111111010110010011000010011000110111001010000110011011111101011110000101\u0026#39;, \u0026#39;0001101000011011010011100100000011010101110110111001111011000001010101101111110100011011010011111010001111011011100011111110101110101101111100100011111110011111010100001100011000111011010111110101000011110101011110110001011110001111011001101100110100000101\u0026#39;] c = 54794426723900547461854843163768660308115034417111329528183606035659639395104723918632912086419836023341428265596988959206660015436864401403237748771765948022232575597127381504670391300908215025163138869313954305720403722718214862988965792884236612959443476803344992121865817757791519151566895512058656532409472494022672998848036223706004788146906885182892250477746430460414866512005225936680732094537985671236900243908114730784290372829952741399684135984046796 print(\u0026#34;Creating list of possible primes\u0026#34;) # the method to decrypt RSA def decr(p,q): try: n = p * q phi = (p-1) * (q-1) d = inverse(e, phi) m = long_to_bytes(pow(c,d,n)) return m except: pass indexes = [0,1,2,3,4,5] primes = [] perm = permutations(indexes,3) done = False # creating a list of permutations for i in perm: primes.append(int(parts[i[0]]+parts[i[1]]+parts[i[2]],2)) prinbaby-baby-rsa.t(\u0026#34;number of possible primes:\u0026#34;, len(primes)) ## nested loop to find the correct permutations to solve the crypto for j in range(len(primes)): print(\u0026#34;checking prime:\u0026#34;,j+1) for k in range(j+1,len(primes)): try: g =decr(primes[j],primes[k]) # when the correct permutations are found, print out the flag, p \u0026amp; q and end the loops if \u0026#34;flag\u0026#34; in g.decode(\u0026#34;utf8\u0026#34;): print(g.decode(\u0026#34;utf8\u0026#34;)) done = True print(\u0026#34;p:\u0026#34;,primes[j]) print(\u0026#34;q:\u0026#34;,primes[k]) break except: pass if done == True: break if done == True: break Output from running the code:\n1 2 3 4 5 6 7 8 Creating list of possible primes number of possible primes: 120 checking prime: 1 ... checking prime: 77 flag{flbg{flcg{fldg{fleg}}}} p: 1476664160874961383698738552409979044438151249443411059273265674671939469667177882159708009897960868174616347274301717201586595990726109094557727941451728900706638729618513258111250206236597947629663658989493197202765392977970356339 q: 1213695317515209399293442202449507480764627122584923884879300426388052747155193495297147582145122423245341251507940719305099731776464932426054136582875291784337820689592625289428081478581173862002897259103133246423738999063613128111 ","permalink":"https://l1ncctf.github.io/post/hsctf9-crypto-baby_baby_rsa/","tags":["HSCTF","Crypto","RSA"],"title":"HSCTF 9 - Baby-baby-rsa"},{"categories":["Writeups","Crypto"],"contents":"Poorly generated random number that allows for a small range to check\nDescription \u0026ldquo;the one-time pad (OTP) is an encryption technique that cannot be cracked\u0026rdquo; - Wikipedia\nSolution Looking at the source code we see a couple of interesting things.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import random from Crypto.Util.number import bytes_to_long def secure_seed(): x = 0 # x is a random integer between 0 and 100000000000 for i in range(10000000000): x += random.randint(0, random.randint(0, 10)) return x flag = open(\u0026#39;flag.txt\u0026#39;,\u0026#39;rb\u0026#39;).read() flag = bytes_to_long(flag) random.seed(secure_seed()) l = len(bin(flag)) - 1 print(l) k = random.getrandbits(l) flag = flag ^ k # super secure encryption print(flag) The code encrypts the flag by generating random bits and does a bitwise XOR, the prints out the length of the flag in binary and the encrypted flag. We also get this as output.txt\n1 2 328 444466166004822947723119817789495250410386698442581656332222628158680136313528100177866881816893557 The \u0026ldquo;randomly\u0026rdquo; generated bits is gotten by using the random.seed() method. By default, this method uses the system time to set the starting number, but if you specify the seed value you actually get the same random number sequence. So what we need to do is to find this seed number, generate the same random bits and XOR the cipher to get the original flag.\nIn this challenge the seed value is generated with the secure_seed() method. Fortunately for us, this method is quite predictable. It loops ten billion times, generating a random integer each time and adding them together. The more you do this, the closer to the average you get, and so the seed number will basically be close to 10000000000 * 2.5.\nAll we have to do is a for loop to test possible seed numbers and to be on the safe side start just just below 25000000000 and iterate up. For each number we use it to start a new seed, generate 328 (the length we got from the output) random bits to XOR with the cipther, and if the result contains \u0026ldquo;flag\u0026rdquo; we break out of the loop. I added a timer to show how long the script takes to find the flag, as well as printing out the seed number used to get the random bits.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import random from Crypto.Util.number import bytes_to_long, long_to_bytes import time # Start timer t0 = time.time() l = 328 f = 444466166004822947723119817789495250410386698442581656332222628158680136313528100177866881816893557 for i in range(24999900000,25500000000): random.seed(i) k = random.getrandbits(328) g = f^k try: res = long_to_bytes(g).decode(\u0026#34;utf8\u0026#34;) if \u0026#34;flag\u0026#34; in res: print(res) print(\u0026#34;seed value:\u0026#34;, i) print(\u0026#34;time:\u0026#34;,time.time()-t0) break except: pass Which generated the output\n1 2 3 4 flag{c3ntr4l_l1m1t_th30r3m_15431008597} seed number: 25000212790 time: 3.0835678577423096 ","permalink":"https://l1ncctf.github.io/post/hsctf9-crypto-otp/","tags":["HSCTF","Crypto"],"title":"HSCTF 9 - OTP"},{"categories":["Writeups","Crypto"],"contents":"Easy crypto that can be solved manually.\nDescription Bob was on his way to school and go to Mr. Connolly’s first period AP CSA class, but it was a rainy day and he got stuck in the quagmire in his town, making him late to school (specifically the first closest to his home, there are apparently four quagmires in his town)! Could you figure out what Mr. Connolly told Bob’s class? His classmate Alice sent this text message after class (written in Quagmire I):\nPlaintext keyword: CONNOLLYROCKS\nIndicator keyword: HSCTF\nIndicator position: A\nCiphertext: LZXORNZBUYWNRARNOVGCLSQWJEFJFE\n(Please wrap the flag in the flag format “flag{}”, and use only uppercase letters within the braces.)\nSolution I had never done a Quagmire crypto before, but after a duckduckgo search I found this link which does a good job in explaining how Quagmire cryptos work. And since this is a Quagmire I, the simplest kind, I opted to just solve it manually.\nWhat you do is to take the plaintext keyword, remove any duplicate characters and then append the rest of the characters of the alphabet (excluding, of course the ones already in the keyword). Next, you make one line for each letter in the indicator keyword and line up the offset so that the letters of the indicator keyword so that is below the indicator position. Lastly, divide the ciphertext into groups of the same length as the indicator keyword.\nNow you are ready to decipher. The firs letter of each group of the cipher corresponds to the first line, the second letter to the second line, and so forth. Just find the letter in the line and the original letter is the one straight above it in the top line (the one that starts with the plaintext keyword).\nBelow you can see the the solution and the deciphered flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 * CONLYRKS A BDEFGHIJMPQTUVWXZ 1 H ZABCDEFG H IJKLMNOPQRSTUVWXY 2 S KLMNOPQR S TUVWXYZABCDEFGHIJ 3 C UVWXYZAB C DEFGHIJKLMNOPQRST 4 T LMNOPQRS T UVWXYZABCDEFGHIJK 5 F XYZABCDE F GHIJKLMNOPQRSTUVW 12345 12345 12345 12345 12345 12345 LZXOR NZBUY WNRAR NOVGC LSQWJ EFJFE FILLT HISBO WLWIT HYOUR FAVEF RUITS flag{FILLTHISBOWLWITHYOURFAVEFRUITS} ","permalink":"https://l1ncctf.github.io/post/hsctf9-crypto-quagmire_i/","tags":["HSCTF","Quagmire"],"title":"HSCTF 9 - Quagmire-I"},{"categories":["Writeups","Web"],"contents":"A simple web challenge involving directory traversal.\nDescription Look at these images I found!\nPoints: 201\nSolves: 303\nURL: http://web1.hsctf.com:8003/\nAdditional attachments: Download\nSolution I believed it was a steganography challenge at first, so I wgetted all of the images on the site and then ran exiftool, but I came back with absolutely nothing.\nUntil on closer inspection at the gallery page, I noticed that the image url had /image?image= and I immediately knew it could be exploited as a path traversal attack due to the images being embedded through the image parameter instead of directly embedding the file (which is more secure than that lol).\nI looked at the source code and noticed this route\n1 2 3 4 5 6 @app.route(\u0026#34;/flag\u0026#34;) def flag(): if 2 + 2 == 5: return send_file(\u0026#34;/flag.txt\u0026#34;) else: return \u0026#34;No.\u0026#34;, 400 This was a clear indication of where the flag is located, but there were a few checks I had to go through.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @app.route(\u0026#34;/image\u0026#34;) def image(): if \u0026#34;image\u0026#34; not in request.args: return \u0026#34;Image not provided\u0026#34;, 400 if \u0026#34;.jpg\u0026#34; not in request.args[\u0026#34;image\u0026#34;]: return \u0026#34;Invalid filename\u0026#34;, 400 file = IMAGE_FOLDER.joinpath(Path(request.args[\u0026#34;image\u0026#34;])) if not file.is_relative_to(IMAGE_FOLDER): return \u0026#34;Invalid filename\u0026#34;, 400 try: return send_file(file.resolve()) except FileNotFoundError: return \u0026#34;File does not exist\u0026#34;, 400 So according to these checks it had to be a .jpg and had to be relative to the directory where the images are located. After seeing the directory relativity check I knew that it could be bypassed with a ../ and so that became apart of my payload as\n../flag.txt\nNow I needed a way to bypass the .jpg check, at first I tried ideas like\n../flag.txt.jpg\nwith a null character in between .txt and .jpg, but that clearly didn\u0026rsquo;t work. Until I looked back at the source code and it hit me, the .jpg didnt have to be at the end of the file, all it needed was to be inside the request parameter, so I crafted\n../.jpg/../flag.txt\nand voilà, I have the flag.\n","permalink":"https://l1ncctf.github.io/post/hsctf9-web-gallery/","tags":["HSCTF","Web"],"title":"HSCTF 9 - Gallery"},{"categories":null,"contents":"","permalink":"https://l1ncctf.github.io/archives/","tags":null,"title":"Archives"}]